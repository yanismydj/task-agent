/**
 * Dual-Context Builder for TaskAgent
 *
 * Builds combined context from:
 * 1. Static repo summary file (.taskagent/repo-summary.json)
 * 2. Dynamic Linear tickets (recently completed work)
 *
 * Features:
 * - On-demand refresh (no caching)
 * - Token budget management with proportional truncation
 * - Graceful degradation if sources unavailable
 */

import fs from 'node:fs';
import { createChildLogger } from './logger.js';
import {
  getRepoSummaryPath as getRepoSummaryPathFromPaths,
  getLegacyRepoSummaryPath,
  migrateLegacyFile,
} from './paths.js';
import type { LinearApiClient } from '../linear/client.js';

const logger = createChildLogger({ module: 'context-builder' });

// Token budget constants (approximate 4 chars per token)
const CHARS_PER_TOKEN = 4;
const DEFAULT_TOKEN_BUDGET = 8000; // ~8k tokens for context
const GUIDELINES_RESERVE = 500; // Reserve tokens for guidelines section

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

interface AutoGeneratedSection {
  path: string;
  name: string;
  description?: string;
  languages: string[];
  frameworks: string[];
  databases: string[];
  testing: string[];
  tooling: string[];
  structure: {
    sourceDir?: string;
    testDir?: string;
    hasDocker: boolean;
    hasCICD: boolean;
  };
  scripts: Record<string, string>;
  dependencies: {
    production: string[];
    development: string[];
  };
  readme?: string;
}

interface ManualSection {
  domainConcepts?: string;
  architectureNotes?: string;
  apiEndpoints?: string;
  dataModels?: string;
  conventions?: string;
  additionalContext?: string;
}

interface EnhancedRepoSummary {
  version: number;
  generatedAt: string;
  lastManualEdit?: string;
  auto: AutoGeneratedSection;
  manual: ManualSection;
  _documentation: string;
}

export interface BuildContextOptions {
  /** Token budget for combined context (default: 8000) */
  tokenBudget?: number;
  /** Include recently completed Linear tickets */
  includeLinearTickets?: boolean;
  /** Linear client for fetching tickets */
  linearClient?: LinearApiClient;
  /** Maximum number of Linear tickets to include */
  maxLinearTickets?: number;
}

export interface ContextBuildResult {
  /** Formatted context string for embedding in prompts */
  context: string;
  /** Estimated token count */
  estimatedTokens: number;
  /** Whether truncation was applied */
  wasTruncated: boolean;
  /** Source availability status */
  sources: {
    repoSummary: boolean;
    linearTickets: boolean;
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// Main Entry Point
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Build dual-context from repo summary and Linear tickets.
 * Refreshes on every call (no caching).
 */
export async function buildDualContext(
  workDir: string,
  options: BuildContextOptions = {}
): Promise<string> {
  const result = await buildDualContextWithMetadata(workDir, options);
  return result.context;
}

/**
 * Build dual-context with metadata about sources and truncation.
 */
export async function buildDualContextWithMetadata(
  workDir: string,
  options: BuildContextOptions = {}
): Promise<ContextBuildResult> {
  const tokenBudget = options.tokenBudget ?? DEFAULT_TOKEN_BUDGET;
  const charBudget = tokenBudget * CHARS_PER_TOKEN;
  const maxLinearTickets = options.maxLinearTickets ?? 10;

  const sections: string[] = [];
  let usedChars = 0;
  let wasTruncated = false;
  const sources = { repoSummary: false, linearTickets: false };

  // 1. Load and format repo summary (always included, never truncated)
  const repoSummary = loadRepoSummary(workDir);
  if (repoSummary) {
    const summarySection = formatRepoSummary(repoSummary);
    sections.push(summarySection);
    usedChars += summarySection.length;
    sources.repoSummary = true;
    logger.debug({ chars: summarySection.length }, 'Loaded repo summary');
  } else {
    logger.debug({ workDir }, 'No repo summary file found');
  }

  // 2. Reserve space for guidelines
  const guidelinesReserve = GUIDELINES_RESERVE * CHARS_PER_TOKEN;

  // 3. Fetch and format Linear tickets with remaining budget
  if (options.includeLinearTickets && options.linearClient) {
    const remainingBudget = Math.max(0, charBudget - usedChars - guidelinesReserve);

    if (remainingBudget > 500) {
      const { section, ticketCount, truncated } = await buildLinearTicketsSection(
        options.linearClient,
        remainingBudget,
        maxLinearTickets
      );

      if (section) {
        sections.push(section);
        usedChars += section.length;
        sources.linearTickets = true;
        wasTruncated = wasTruncated || truncated;
        logger.debug({ ticketCount, truncated }, 'Added Linear tickets section');
      }
    } else {
      logger.debug({ remainingBudget }, 'Insufficient budget for Linear tickets');
      wasTruncated = true;
    }
  }

  // 4. Add guidelines section (always included)
  const guidelinesSection = buildGuidelinesFromContext(repoSummary);
  sections.push(guidelinesSection);
  usedChars += guidelinesSection.length;

  const context = sections.join('\n\n');
  const estimatedTokens = estimateTokens(context);

  logger.info({
    estimatedTokens,
    wasTruncated,
    sources,
    charCount: context.length,
  }, 'Built dual context');

  return {
    context,
    estimatedTokens,
    wasTruncated,
    sources,
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// Repo Summary Loading
// ═══════════════════════════════════════════════════════════════════════════

function loadRepoSummary(workDir: string): EnhancedRepoSummary | null {
  const summaryPath = getRepoSummaryPathFromPaths(workDir);
  const legacyPath = getLegacyRepoSummaryPath(workDir);

  // Migrate from legacy path if needed
  if (migrateLegacyFile(legacyPath, summaryPath)) {
    logger.info({ from: legacyPath, to: summaryPath }, 'Migrated repo summary from legacy path');
  }

  try {
    if (!fs.existsSync(summaryPath)) {
      return null;
    }

    const content = fs.readFileSync(summaryPath, 'utf-8');
    const parsed = JSON.parse(content);

    // Handle both old and new schema formats
    if (parsed.version && parsed.auto) {
      // New enhanced format
      return parsed as EnhancedRepoSummary;
    } else if (parsed.path && parsed.name) {
      // Legacy format - wrap in new structure
      return {
        version: 0,
        generatedAt: parsed.generatedAt || new Date().toISOString(),
        auto: {
          path: parsed.path,
          name: parsed.name,
          description: parsed.description,
          languages: parsed.languages || [],
          frameworks: parsed.frameworks || [],
          databases: parsed.databases || [],
          testing: parsed.testing || [],
          tooling: parsed.tooling || [],
          structure: parsed.structure || { hasDocker: false, hasCICD: false },
          scripts: parsed.scripts || {},
          dependencies: parsed.dependencies || { production: [], development: [] },
          readme: parsed.readme,
        },
        manual: {},
        _documentation: '',
      };
    }

    logger.warn({ summaryPath }, 'Unknown repo summary format');
    return null;
  } catch (error) {
    logger.warn({ workDir, error }, 'Failed to load repo summary');
    return null;
  }
}

function formatRepoSummary(summary: EnhancedRepoSummary): string {
  const { auto, manual } = summary;
  const lines: string[] = [];

  // Header
  lines.push(`## Repository: ${auto.name}`);
  if (auto.description) {
    lines.push(auto.description);
  }

  // Tech stack (auto-generated)
  const techLines: string[] = [];
  if (auto.languages.length > 0) {
    techLines.push(`- **Languages**: ${auto.languages.join(', ')}`);
  }
  if (auto.frameworks.length > 0) {
    techLines.push(`- **Frameworks**: ${auto.frameworks.join(', ')}`);
  }
  if (auto.databases.length > 0) {
    techLines.push(`- **Databases**: ${auto.databases.join(', ')}`);
  }
  if (auto.testing.length > 0) {
    techLines.push(`- **Testing**: ${auto.testing.join(', ')}`);
  }
  if (auto.tooling.length > 0) {
    techLines.push(`- **Tooling**: ${auto.tooling.join(', ')}`);
  }

  if (techLines.length > 0) {
    lines.push('\n### Tech Stack');
    lines.push(...techLines);
  }

  // Architecture (auto-generated)
  const archParts: string[] = [];
  if (auto.structure.sourceDir) {
    archParts.push(`- **Source**: \`${auto.structure.sourceDir}/\``);
  }
  if (auto.structure.testDir) {
    archParts.push(`- **Tests**: \`${auto.structure.testDir}/\``);
  }
  if (auto.structure.hasDocker) {
    archParts.push('- **Container**: Docker');
  }
  if (auto.structure.hasCICD) {
    archParts.push('- **CI/CD**: Configured');
  }

  if (archParts.length > 0) {
    lines.push('\n### Architecture');
    lines.push(...archParts);
  }

  // Manual sections (higher priority - include all non-empty)
  if (manual.domainConcepts) {
    lines.push('\n### Domain Concepts');
    lines.push(manual.domainConcepts);
  }

  if (manual.architectureNotes) {
    lines.push('\n### Architecture Notes');
    lines.push(manual.architectureNotes);
  }

  if (manual.apiEndpoints) {
    lines.push('\n### Key API Endpoints');
    lines.push(manual.apiEndpoints);
  }

  if (manual.dataModels) {
    lines.push('\n### Data Models');
    lines.push(manual.dataModels);
  }

  if (manual.conventions) {
    lines.push('\n### Conventions');
    lines.push(manual.conventions);
  }

  if (manual.additionalContext) {
    lines.push('\n### Additional Context');
    lines.push(manual.additionalContext);
  }

  // README summary (truncated)
  if (auto.readme) {
    const truncatedReadme = auto.readme.slice(0, 300);
    lines.push('\n### About');
    lines.push(truncatedReadme + (auto.readme.length > 300 ? '...' : ''));
  }

  return lines.join('\n');
}

// ═══════════════════════════════════════════════════════════════════════════
// Linear Tickets Section
// ═══════════════════════════════════════════════════════════════════════════

interface LinearSectionResult {
  section: string | null;
  ticketCount: number;
  truncated: boolean;
}

async function buildLinearTicketsSection(
  linearClient: LinearApiClient,
  charBudget: number,
  maxTickets: number
): Promise<LinearSectionResult> {
  try {
    // Get completed tickets from cache
    const tickets = linearClient.getCachedTickets();

    // Filter to completed only and sort by most recently updated
    const completedTickets = tickets
      .filter((t) => t.state.type === 'completed')
      .sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime())
      .slice(0, maxTickets);

    if (completedTickets.length === 0) {
      return { section: null, ticketCount: 0, truncated: false };
    }

    const header = '### Recent Completed Work';
    const lines: string[] = [header];
    let currentLength = header.length;
    let ticketCount = 0;
    let truncated = false;

    for (const ticket of completedTickets) {
      // Format: - **TAS-123**: Title (truncated to 80 chars)
      const title = ticket.title.length > 80
        ? ticket.title.slice(0, 77) + '...'
        : ticket.title;
      const ticketLine = `- **${ticket.identifier}**: ${title}`;

      // Check if adding this would exceed budget
      if (currentLength + ticketLine.length + 2 > charBudget) {
        truncated = true;
        logger.debug(
          { ticketCount, charBudget, currentLength },
          'Truncating Linear tickets due to token budget'
        );
        break;
      }

      lines.push(ticketLine);
      currentLength += ticketLine.length + 1;
      ticketCount++;
    }

    if (ticketCount === 0) {
      return { section: null, ticketCount: 0, truncated };
    }

    return {
      section: lines.join('\n'),
      ticketCount,
      truncated: truncated || ticketCount < completedTickets.length,
    };
  } catch (error) {
    logger.warn({ error }, 'Failed to build Linear tickets section');
    return { section: null, ticketCount: 0, truncated: false };
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Guidelines Section
// ═══════════════════════════════════════════════════════════════════════════

function buildGuidelinesFromContext(summary: EnhancedRepoSummary | null): string {
  const doNotAsk: string[] = [];
  const focusOn: string[] = [
    'Business logic decisions',
    'User experience choices',
    'Edge cases and error handling preferences',
    'Scope clarification (what\'s in/out of scope)',
  ];

  if (summary?.auto) {
    const auto = summary.auto;

    // Language detection
    if (auto.languages.includes('TypeScript')) {
      doNotAsk.push('Language choice (TypeScript is already used)');
    } else if (auto.languages.includes('JavaScript')) {
      doNotAsk.push('Language choice (JavaScript is already used)');
    }

    // Framework detection
    if (auto.frameworks.length > 0) {
      const frameworks = auto.frameworks.join('/');
      doNotAsk.push(`Framework choice (${frameworks} is already used)`);
    }

    // Database detection
    if (auto.databases.length > 0) {
      const databases = auto.databases.join('/');
      doNotAsk.push(`Database/ORM choice (${databases} is already used)`);
    }

    // Testing detection
    if (auto.testing.length > 0) {
      const testing = auto.testing.join('/');
      doNotAsk.push(`Testing framework (${testing} is already used)`);
    }
  }

  if (doNotAsk.length === 0) {
    doNotAsk.push('Technology choices evident from the codebase');
  }

  return `### Guidelines for Questions

**DO NOT ask about:**
${doNotAsk.map((item) => `- ${item}`).join('\n')}

**FOCUS questions on:**
${focusOn.map((item) => `- ${item}`).join('\n')}`;
}

// ═══════════════════════════════════════════════════════════════════════════
// Utilities
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Estimate token count from text length
 */
export function estimateTokens(text: string): number {
  return Math.ceil(text.length / CHARS_PER_TOKEN);
}

/**
 * Check if repo summary file exists (checks both new and legacy paths)
 */
export function hasRepoSummary(workDir: string): boolean {
  const summaryPath = getRepoSummaryPathFromPaths(workDir);
  const legacyPath = getLegacyRepoSummaryPath(workDir);
  return fs.existsSync(summaryPath) || fs.existsSync(legacyPath);
}

/**
 * Get repo summary path for a work directory
 * Re-exported from paths module for backward compatibility
 */
export function getRepoSummaryPath(workDir: string): string {
  return getRepoSummaryPathFromPaths(workDir);
}
