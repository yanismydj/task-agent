#!/usr/bin/env npx tsx
/**
 * Generate repository summary for TaskAgent
 * Usage: npx tsx scripts/generate-repo-summary.ts [path]
 *
 * This creates a .taskagent/repo-summary.json file with:
 * - auto: Auto-generated sections (tech stack, dependencies, scripts)
 * - manual: Sections for developers to edit (domain concepts, API endpoints, etc.)
 *
 * The manual sections should be edited by developers to provide context that
 * cannot be automatically detected from the codebase.
 */

import fs from 'node:fs';
import path from 'node:path';
import { config as loadEnv } from 'dotenv';

loadEnv();

const PROJECT_ROOT = path.resolve(import.meta.dirname, '..');
const TASKAGENT_DIR = path.join(PROJECT_ROOT, '.taskagent');
const REPO_SUMMARY_PATH = path.join(TASKAGENT_DIR, 'repo-summary.json');
const LEGACY_REPO_SUMMARY_PATH = path.join(PROJECT_ROOT, '.task-agent-repo-summary.json');

// Ensure .taskagent directory exists
function ensureTaskAgentDir(): void {
  if (!fs.existsSync(TASKAGENT_DIR)) {
    fs.mkdirSync(TASKAGENT_DIR, { recursive: true });
  }
}

// Migrate legacy repo summary if needed
function migrateLegacyRepoSummary(): void {
  if (fs.existsSync(LEGACY_REPO_SUMMARY_PATH) && !fs.existsSync(REPO_SUMMARY_PATH)) {
    ensureTaskAgentDir();
    fs.renameSync(LEGACY_REPO_SUMMARY_PATH, REPO_SUMMARY_PATH);
    console.log(`Migrated repo summary from ${LEGACY_REPO_SUMMARY_PATH} to ${REPO_SUMMARY_PATH}`);
  }
}

// Auto-generated section - populated by scanning the filesystem
interface AutoGeneratedSection {
  path: string;
  name: string;
  description?: string;
  languages: string[];
  frameworks: string[];
  databases: string[];
  testing: string[];
  tooling: string[];
  structure: {
    sourceDir?: string;
    testDir?: string;
    hasDocker: boolean;
    hasCICD: boolean;
  };
  scripts: Record<string, string>;
  dependencies: {
    production: string[];
    development: string[];
  };
  readme?: string;
}

// Manual section - edited by developers to add domain knowledge
interface ManualSection {
  // Key domain concepts and business logic that agents should understand
  domainConcepts?: string;
  // Architecture decisions and patterns used in the codebase
  architectureNotes?: string;
  // Key API endpoints and their purposes
  apiEndpoints?: string;
  // Important data models and their relationships
  dataModels?: string;
  // Code conventions not captured in linter configs
  conventions?: string;
  // Any additional context helpful for agents
  additionalContext?: string;
}

// Full repo summary schema
interface EnhancedRepoSummary {
  // Schema version for future migrations
  version: number;
  // When the auto section was last generated
  generatedAt: string;
  // When a developer last edited the manual section
  lastManualEdit?: string;
  // Auto-generated content from filesystem analysis
  auto: AutoGeneratedSection;
  // Developer-edited content for domain knowledge
  manual: ManualSection;
  // Documentation on how to maintain this file
  _documentation: string;
}

// Legacy format for migration
interface LegacyRepoSummary {
  path: string;
  name: string;
  description?: string;
  languages: string[];
  frameworks: string[];
  databases: string[];
  testing: string[];
  tooling: string[];
  structure: {
    sourceDir?: string;
    testDir?: string;
    hasDocker: boolean;
    hasCICD: boolean;
  };
  scripts: Record<string, string>;
  dependencies: {
    production: string[];
    development: string[];
  };
  readme?: string;
  generatedAt: string;
}

const EXCLUDED_DIRS = new Set([
  'node_modules', '.git', '.task-agent', 'dist', 'build', 'coverage',
  '.next', '.nuxt', '__pycache__', '.venv', 'venv', '.cache', '.turbo',
  'vendor', 'target', 'bin', 'obj', '.idea', '.vscode',
]);

function analyzeNodeProject(workDir: string, packageJsonPath: string, summary: AutoGeneratedSection): void {
  try {
    const content = fs.readFileSync(packageJsonPath, 'utf-8');
    const pkg = JSON.parse(content);

    summary.name = pkg.name || summary.name;
    summary.description = pkg.description;

    const deps = Object.keys(pkg.dependencies || {});
    const devDeps = Object.keys(pkg.devDependencies || {});
    const allDeps = [...deps, ...devDeps];

    summary.dependencies.production = deps.slice(0, 20);
    summary.dependencies.development = devDeps.slice(0, 20);

    if (allDeps.includes('typescript') || fs.existsSync(path.join(workDir, 'tsconfig.json'))) {
      summary.languages.push('TypeScript');
    } else {
      summary.languages.push('JavaScript');
    }

    if (allDeps.includes('next')) summary.frameworks.push('Next.js');
    else if (allDeps.includes('react')) summary.frameworks.push('React');
    if (allDeps.includes('vue')) summary.frameworks.push('Vue.js');
    if (allDeps.includes('express')) summary.frameworks.push('Express.js');
    if (allDeps.includes('fastify')) summary.frameworks.push('Fastify');
    if (allDeps.includes('@nestjs/core')) summary.frameworks.push('NestJS');
    if (allDeps.includes('hono')) summary.frameworks.push('Hono');

    if (allDeps.includes('prisma') || allDeps.includes('@prisma/client')) summary.databases.push('Prisma');
    if (allDeps.includes('mongoose')) summary.databases.push('MongoDB (Mongoose)');
    if (allDeps.includes('pg') || allDeps.includes('postgres')) summary.databases.push('PostgreSQL');
    if (allDeps.includes('better-sqlite3') || allDeps.includes('sqlite3')) summary.databases.push('SQLite');
    if (allDeps.includes('redis') || allDeps.includes('ioredis')) summary.databases.push('Redis');
    if (allDeps.includes('drizzle-orm')) summary.databases.push('Drizzle ORM');

    if (allDeps.includes('jest')) summary.testing.push('Jest');
    if (allDeps.includes('vitest')) summary.testing.push('Vitest');
    if (allDeps.includes('mocha')) summary.testing.push('Mocha');
    if (allDeps.includes('@playwright/test')) summary.testing.push('Playwright');
    if (allDeps.includes('cypress')) summary.testing.push('Cypress');

    if (allDeps.includes('eslint')) summary.tooling.push('ESLint');
    if (allDeps.includes('prettier')) summary.tooling.push('Prettier');
    if (allDeps.includes('husky')) summary.tooling.push('Husky');
    if (allDeps.includes('tsx')) summary.tooling.push('tsx');
    if (allDeps.includes('zod')) summary.tooling.push('Zod');
    if (allDeps.includes('pino')) summary.tooling.push('Pino');

    if (pkg.scripts) {
      const importantScripts = ['build', 'dev', 'start', 'test', 'lint', 'typecheck', 'format', 'init', 'auth'];
      for (const script of importantScripts) {
        if (pkg.scripts[script]) {
          summary.scripts[script] = pkg.scripts[script];
        }
      }
    }
  } catch (error) {
    console.warn(`Failed to parse package.json: ${error}`);
  }
}

function scanDirectoryStructure(workDir: string, summary: AutoGeneratedSection): void {
  try {
    const entries = fs.readdirSync(workDir, { withFileTypes: true });

    for (const entry of entries) {
      const name = entry.name;

      if (entry.isDirectory()) {
        if (EXCLUDED_DIRS.has(name)) continue;

        if (['src', 'lib', 'app', 'source', 'pkg', 'internal', 'cmd'].includes(name)) {
          summary.structure.sourceDir = name;
        }

        if (['test', 'tests', '__tests__', 'spec', 'specs'].includes(name)) {
          summary.structure.testDir = name;
        }

        if (['.github', '.gitlab', '.circleci', '.buildkite'].includes(name)) {
          summary.structure.hasCICD = true;
        }
      } else if (entry.isFile()) {
        if (name === 'Dockerfile' || name.startsWith('docker-compose')) {
          summary.structure.hasDocker = true;
          if (!summary.tooling.includes('Docker')) summary.tooling.push('Docker');
        }

        if (name === 'tsconfig.json' && !summary.tooling.includes('TypeScript')) {
          summary.tooling.push('TypeScript');
        }
      }
    }
  } catch (error) {
    console.warn(`Failed to scan directory: ${error}`);
  }
}

function getReadmeSummary(workDir: string): string | undefined {
  const readmeNames = ['README.md', 'readme.md', 'README', 'README.txt'];

  for (const name of readmeNames) {
    const readmePath = path.join(workDir, name);
    try {
      if (fs.existsSync(readmePath)) {
        const content = fs.readFileSync(readmePath, 'utf-8');
        const lines = content.split('\n');
        const paragraphs: string[] = [];
        let foundContent = false;

        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.startsWith('#') || trimmed.startsWith('![') || trimmed.startsWith('[![')) {
            continue;
          }
          if (trimmed.length > 0) {
            paragraphs.push(trimmed);
            foundContent = true;
            if (paragraphs.join(' ').length > 500) break;
          } else if (foundContent && paragraphs.length > 0) {
            break;
          }
        }

        const summary = paragraphs.join(' ').slice(0, 500);
        return summary.length > 0 ? summary : undefined;
      }
    } catch {
      continue;
    }
  }

  return undefined;
}

const DOCUMENTATION = `
This file contains context about your repository for TaskAgent.

SECTIONS:
- auto: Auto-generated by running 'npx tsx scripts/generate-repo-summary.ts'
        DO NOT edit this section manually - it will be overwritten.

- manual: Edit these fields to provide domain knowledge that cannot be
          automatically detected. This helps TaskAgent ask better questions
          and generate more relevant code.

MANUAL SECTION FIELDS:
- domainConcepts: Explain key business concepts, domain terminology, and
                  business rules that agents should understand.
                  Example: "Users can have multiple 'workspaces'. Each workspace
                  has 'projects' and 'tickets'. Tickets go through states:
                  backlog -> in_progress -> review -> done."

- architectureNotes: Describe key architectural decisions, patterns used,
                     and why certain approaches were chosen.
                     Example: "We use event sourcing for audit trails.
                     All mutations go through the command bus in src/commands/."

- apiEndpoints: Document key API routes and their purposes.
                Example: "POST /api/tickets - Create new ticket (requires auth)
                         GET /api/tickets/:id - Get ticket details"

- dataModels: Describe important data models and their relationships.
              Example: "Ticket has: title, description, state, assignee.
                       State is a foreign key to WorkflowState."

- conventions: Document code conventions not captured by linters.
               Example: "Use 'handle' prefix for event handlers.
                        Use 'build' prefix for factory functions."

WHEN TO UPDATE:
- Run the generator script after major dependency changes
- Edit manual sections when adding new features or changing domain logic
- Review and update when onboarding new team members
`.trim();

function analyzeRepository(workDir: string): EnhancedRepoSummary {
  console.log(`\nAnalyzing repository: ${workDir}\n`);

  // Check for existing file to preserve manual sections
  // Check both new and legacy paths
  let existingManual: ManualSection = {};
  let existingLastManualEdit: string | undefined;

  const newSummaryPath = path.join(workDir, '.taskagent', 'repo-summary.json');
  const legacySummaryPath = path.join(workDir, '.task-agent-repo-summary.json');
  const existingSummaryPath = fs.existsSync(newSummaryPath) ? newSummaryPath : legacySummaryPath;

  if (fs.existsSync(existingSummaryPath)) {
    try {
      const existing = JSON.parse(fs.readFileSync(existingSummaryPath, 'utf-8'));
      // Check if it's the new format with manual section
      if (existing.manual) {
        existingManual = existing.manual;
        existingLastManualEdit = existing.lastManualEdit;
        console.log('  Preserving existing manual sections...');
      }
    } catch {
      // Ignore parse errors, start fresh
    }
  }

  const auto: AutoGeneratedSection = {
    path: workDir,
    name: path.basename(workDir),
    languages: [],
    frameworks: [],
    databases: [],
    testing: [],
    tooling: [],
    structure: {
      hasDocker: false,
      hasCICD: false,
    },
    scripts: {},
    dependencies: {
      production: [],
      development: [],
    },
  };

  const packageJsonPath = path.join(workDir, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    analyzeNodeProject(workDir, packageJsonPath, auto);
  }

  scanDirectoryStructure(workDir, auto);
  auto.readme = getReadmeSummary(workDir);

  return {
    version: 1,
    generatedAt: new Date().toISOString(),
    lastManualEdit: existingLastManualEdit,
    auto,
    manual: existingManual,
    _documentation: DOCUMENTATION,
  };
}

function displaySummary(summary: EnhancedRepoSummary): void {
  const { auto, manual } = summary;

  console.log('═══════════════════════════════════════════════════════════');
  console.log('                    REPOSITORY SUMMARY');
  console.log('═══════════════════════════════════════════════════════════\n');

  console.log(`  Name:        ${auto.name}`);
  if (auto.description) {
    console.log(`  Description: ${auto.description}`);
  }
  console.log(`  Path:        ${auto.path}`);

  if (auto.languages.length > 0) {
    console.log(`\n  Languages:   ${auto.languages.join(', ')}`);
  }

  if (auto.frameworks.length > 0) {
    console.log(`  Frameworks:  ${auto.frameworks.join(', ')}`);
  }

  if (auto.databases.length > 0) {
    console.log(`  Databases:   ${auto.databases.join(', ')}`);
  }

  if (auto.testing.length > 0) {
    console.log(`  Testing:     ${auto.testing.join(', ')}`);
  }

  if (auto.tooling.length > 0) {
    console.log(`  Tooling:     ${auto.tooling.join(', ')}`);
  }

  const structureParts: string[] = [];
  if (auto.structure.sourceDir) structureParts.push(`source: ${auto.structure.sourceDir}/`);
  if (auto.structure.testDir) structureParts.push(`tests: ${auto.structure.testDir}/`);
  if (auto.structure.hasDocker) structureParts.push('Docker');
  if (auto.structure.hasCICD) structureParts.push('CI/CD');

  if (structureParts.length > 0) {
    console.log(`  Structure:   ${structureParts.join(', ')}`);
  }

  if (Object.keys(auto.scripts).length > 0) {
    console.log('\n  Available Scripts:');
    for (const [name, cmd] of Object.entries(auto.scripts)) {
      const displayCmd = cmd.length > 50 ? cmd.slice(0, 47) + '...' : cmd;
      console.log(`    ${name}: ${displayCmd}`);
    }
  }

  if (auto.readme) {
    console.log('\n  About:');
    console.log(`    ${auto.readme.slice(0, 200)}${auto.readme.length > 200 ? '...' : ''}`);
  }

  // Show manual sections if populated
  const manualFields = Object.entries(manual).filter(([_, v]) => v);
  if (manualFields.length > 0) {
    console.log('\n  Manual Sections:');
    for (const [key, _] of manualFields) {
      console.log(`    - ${key}: (populated)`);
    }
  } else {
    console.log('\n  Manual Sections: (none - edit the JSON file to add domain context)');
  }

  console.log('\n═══════════════════════════════════════════════════════════\n');
}

async function main(): Promise<void> {
  const workDir = process.argv[2] || process.env.AGENTS_WORK_DIR;

  if (!workDir) {
    console.error('Usage: npx tsx scripts/generate-repo-summary.ts [path]');
    console.error('Or set AGENTS_WORK_DIR in .env');
    process.exit(1);
  }

  if (!fs.existsSync(workDir)) {
    console.error(`Directory does not exist: ${workDir}`);
    process.exit(1);
  }

  // Migrate legacy repo summary if exists
  migrateLegacyRepoSummary();

  const summary = analyzeRepository(workDir);
  displaySummary(summary);

  // Ensure .taskagent directory exists
  ensureTaskAgentDir();
  fs.writeFileSync(REPO_SUMMARY_PATH, JSON.stringify(summary, null, 2));
  console.log(`Summary saved to: ${REPO_SUMMARY_PATH}`);
}

main();
